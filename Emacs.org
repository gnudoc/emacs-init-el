#+title: Emacs From Scratch config
#+PROPERTY: header-args :tangle ./init.el :mkdirp yes
#+STARTUP: content

* Early-Init Config
This section contains all code that should be tangled to =early-init.el=.
It runs *before* package initialization and frame drawing. 
#+HEADER: :tangle ./early-init.el
#+begin_src emacs-lisp
  ;; This should be $HOME/.config/early-init.el
  (setq gc-cons-threshold most-positive-fixnum) ;; Defer GC during startup
  (setq package-enable-at-startup nil)
  (setq inhibit-startup-message t)

  ;; Disable UI elements before they are even drawn
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)

  ;; Set frame defaults early - but only when in graphical session
  (when (display-graphic-p)
    (add-to-list 'default-frame-alist '(alpha-background . 90))
    (add-to-list 'default-frame-alist '(fullscreen . maximized)))
#+end_src
* Main Init Config
#+PROPERTY: header-args :tangle ./init.el :mkdirp yes
This main section all gets tangled to init.el
** Preamble
Add a general intro to the init.el file.
Also, remember to consider adding any new mode to the list of exceptions for global-display-line-numbers-mode
#+begin_src emacs-lisp
  ;; This should be $HOME/.config/init.el
  ;; Note that init.el is generated from ./Emacs.org - that is the file that should be edited
  ;; on first install, do M-x all-the-icons-install-fonts, M-x treesit-install-language-grammar
  ;; M-x nerd-icons-install-fonts and M-x pdf-tools-install

  
#+end_src
** Package and System Setup
*** Elpaca

Using [[https://github.com/progfolio/elpaca][elpaca]] for fast, parallel, and reproducible package management.
This code is based on the official README and I haven't really tried to understand it yet
#+begin_src emacs-lisp
  ;; --- Elpaca Bootstrap ---
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                               :ref nil :depth 1 :inherit ignore
                               :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                               :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                        ,@(when-let* ((depth (plist-get order :depth)))
                                                            (list (format "--depth=%d" depth) "--no-single-branch"))
                                                        ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

  ;; --- Elpaca use-package Integration ---
  
  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable use-package :ensure support for elpaca.
    (elpaca-use-package-mode)
    ;; Make elpaca manage all use-package declarations by default.
    (setq elpaca-use-package-by-default t))

#+end_src
*** No Littering
By default, packages dump various files and dirs in the .emacs.d dir - let's make them use ./var and ./etc
#+begin_src emacs-lisp
  (use-package no-littering
    :ensure t
    :config
    ;; Keep auto-save files in the same separate directory
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+end_src
*** Shell PATH
Ensure Emacs inherits the system $PATH so it can test for programs in the rest of the config
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config
    (when (display-graphic-p)
      (setq exec-path-from-shell-variables '("PATH" "MANPATH" "SSH_AUTH_SOCK"))
      (exec-path-from-shell-initialize)))
#+end_src
** Core Emacs Config
This section configures core Emacs behavior, fonts, and helper functions.
*** Garbage Collection
#+begin_src emacs-lisp
  ;; Reset GC threshold to a sane default after startup
  (use-package gcmh
    :ensure t
    :diminish gcmh-mode
    :init
    ;; Set the "high" threshold for when Emacs is idle (e.g., 32MB)
    (setq gcmh-high-cons-threshold (* 32 1024 1024)) 
    :config
    (gcmh-mode 1))
#+end_src
*** Custom Variables
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :init
    ;; Save Custom-set variables to a separate file, not init.el
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    ;; Load it if it exists
    (when (file-exists-p custom-file)
      (load custom-file))
    :config
    (when (and (fboundp 'native-comp-available-p)
               (native-comp-available-p))
      (setq native-comp-async-report-warnings-errors 'silent) ;; Stop annoying warnings popping up
      (setq native-comp-jit-compilation t)))
#+end_src
*** Basic UI Tweaks
Configuring the basic look and feel, like line numbers and the bell.
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    ;; --- Basic UI Tweaks ---
    (column-number-mode)
    (global-display-line-numbers-mode t)
    (setq visible-bell t)

    ;; Disable line numbers in modes where they don't make sense
    (dolist (mode '(org-mode-hook
                    term-mode-hook
                    vterm-mode-hook
  		  eat-mode-hook
                    shell-mode-hook 
                    eshell-mode-hook
                    eww-mode-hook
                    pdf-view-mode-hook
  		  nov-mode-hook
  		  rec-mode-hook))
      (add-hook mode (lambda () (display-line-numbers-mode 0))))

    ;; --- GUI Specific Tweaks (that don't belong in early-init) ---
    (when (display-graphic-p)
      (set-fringe-mode 5)) 
    )
#+end_src
*** Font Configuration
We'll try to find our preferred fonts. On Linux, we want [[https://github.com/tonsky/FiraCode][FiraCode]] (for code) and [[https://fonts.google.com/specimen/Cantarell][Cantarell]] (for variable-pitch text like Org headings).
On windows, we'll fall back to Consolas and Segoe UI .
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :config
    ;; --- Font Configuration ---
    (cond
     ((find-font (font-spec :name "FiraCode Nerd Font"))
      (message "Using FiraCode Nerd Font")
      (set-face-attribute 'default nil :font "FiraCode Nerd Font" :height 130)
      (set-face-attribute 'fixed-pitch nil :font "FiraCode Nerd Font" :height 130))
     ((find-font (font-spec :name "Consolas"))
      (message "Using Consolas as a fallback")
      (set-face-attribute 'default nil :font "Consolas" :height 130) 
      (set-face-attribute 'fixed-pitch nil :font "Consolas" :height 130))
     (t
      (message "Neither FiraCode nor Consolas found, using emacs default.")))

    (cond
     ((find-font (font-spec :name "Cantarell"))
      (message "Using Cantarell for variable-pitch")
      (set-face-attribute 'variable-pitch nil :font "Cantarell" :height 140 :weight 'regular)) 
     ((find-font (font-spec :name "Segoe UI"))
      (message "Using Segoe UI as a fallback for variable pitch") 
      (set-face-attribute 'variable-pitch nil :font "Segoe UI" :height 140 :weight 'regular))
     (t
      (message "Neither Cantarell nor Segoe UI found, using emacs default."))))
#+end_src
*** Helper Functions
Custom Elisp functions used elsewhere in the configuration .
#+begin_src emacs-lisp
  (defun nij/all-the-icons-available-p ()
    "Check if we are in GUI and all-the-icons fonts are installed."
    (and (display-graphic-p) (member "all-the-icons" (font-family-list))))

  (defun nij/consult-grep-or-ripgrep ()
    "Run `consult-ripgrep` if available, otherwise fall back to `consult-grep`."
    (interactive)
    (if (executable-find "rg")
        (call-interactively #'consult-ripgrep)
      (call-interactively #'consult-grep)))

  (defun nij/prettier-format-on-save ()
    "Add prettier-js-before-save to the buffer-local before-save-hook."
    (add-hook 'before-save-hook 'prettier-js-before-save nil t))
  (defun nij/shell-other-window ()
    "Open a 'shell' buffer in another window"
    (interactive)
    (let ((buf (shell)))
      (switch-to-buffer (other-buffer buf))
      (switch-to-buffer-other-window buf))
    )
#+end_src
** More UI and UX Config
Theming, Completion and Help
*** Colour Theme
Take suggestions from [[https://github.com/hlissner/emacs-doom-themes][doom-themes]]
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :init (load-theme 'doom-dracula t))
#+end_src
*** Modeline
Another element of doom emacs that's nice is [[https://github.com/seagle0128/doom-modeline][modeline]]. It has a bunch of its own config options, and on first run it needs =M-x all-the-icons-install-fonts=
#+begin_src emacs-lisp
  (use-package all-the-icons :ensure t)
  (use-package nerd-icons :ensure t)
  (use-package doom-modeline
    :ensure t
    :after (all-the-icons nerd-icons)
    :init (doom-modeline-mode 1)
    :config
    (if (nij/all-the-icons-available-p)
        (setq doom-modeline-height 15)
      (setq doom-modeline-mode 10)))
#+end_src
*** Which Key
[[https://github.com/justbur/emacs-which-key][which-key]] offers all completions for any key prefix - now part of default emacs.
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :diminish which-key-mode
    :config
    (which-key-mode 1)
    (setq which-key-idle-delay 0.5))
#+end_src
*** Vertico and Consult stacks
The modern, minimal replacement for Ivy, Counsel, and Ivy-rich.
**** Vertico
The vertical completion UI
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (vertico-mode 1)
    ;; Add cycling with TAB
    (setq vertico-cycle t))
#+end_src
**** Orderless
The completion style, allowing flexible, out-of-order matching
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :config
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion))))))
#+end_src
**** Consult
Search and Nav functions
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind
    (("M-x" . execute-extended-command)
     ("C-x b" . consult-buffer) ;; A good replacement for counsel-ibuffer
     :map minibuffer-local-map
     ("C-r" . consult-history)
     ("C-c g" . nij/consult-grep-or-ripgrep)
     ))
#+end_src
**** Marginalia
Rich annotations
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :after vertico
    :init
    (marginalia-mode 1))
#+end_src
**** Embark
Contextual items for the completion results
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :bind
    (("C-." . embark-act)
     ("C-," . embark-collect)
     ("C-;" . embark-dwim) ; "Do What I Mean"
     ("C-h B" . embark-bindings)))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src
*** Helpful
[[https://github.com/Wilfred/helpful][Helpful]] adds more info to the =describe-*= buffers
#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    ;; Remap the default describe-* commands to helpful's versions
    ([remap describe-function] . helpful-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src
** Org Mode
The famous magic [[https://orgmode.org][Org Mode]]. All sorts of functions. Rich doc editing, project planning, task/time tracking, literate coding, blogging engine, and more.
*** Fonts in Org
A helper function for fonts, with a conditional checking for the variable fonts we like
#+begin_src emacs-lisp
  (defun nij/org-font-setup ()
    ;(font-lock-add-keywords 'org-mode
    ;			  '(("^ *\([-]\) "
    ;			     (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
    (let ((variable-font
           (cond
            ((find-font (font-spec :name "Cantarell")) "Cantarell")
            ((find-font (font-spec :name "Segoe UI")) "Segoe UI")
            (t nil))))
      (when variable-font
        (dolist (face '((org-level-1 . 1.2)
                        (org-level-2 . 1.1)
                        (org-level-3 . 1.05)
                        (org-level-4 . 1.0)
                        (org-level-5 . 1.0)
                        (org-level-6 . 1.0)
                        (org-level-7 . 1.0)
                        (org-level-8 . 1.0)))
          (set-face-attribute (car face) nil :font variable-font :weight 'regular :height (cdr face)))))

    (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))
#+end_src
*** Basic Config
Here are some basics. See systemcrafters emacs-from-scratch for examples.
#+begin_src emacs-lisp
  (defun nij/org-mode-setup ()
    "Main org-mode setup function"
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (nij/org-font-setup))

  (use-package org
    :ensure nil
    :hook (org-mode . nij/org-mode-setup)
    :config
    (setq org-ellipsis " ▾"))
#+end_src
*** Org & Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))

  ;; For exporting Org to MkDocs-compatible Markdown
  (use-package ox-gfm 
    :ensure t 
    :after org)
#+end_src
*** Org Modern
Use org-modern for enhanced display, including custom priorities instead of my custom code and the org-superstar code
#+begin_src emacs-lisp
  (use-package org-modern
      :ensure t
      :hook ((org-mode . org-modern-mode))
      :config
      ;; This replaces 'org-superstar-headline-bullets-list'
      (setq org-modern-headline-bullets
            '((1 . "◉")
              (2 . "○")
              (3 . "●")
              (4 . "○")
              (5 . "●")
              (6 . "○")
              (7 . "●")))
      
      ;; This replaces 'org-superstar-prettify-item-priority'
      (setq org-modern-prettify-priorities t)
      
      ;; This will prettify plain lists (like * or -) as well
      (setq org-modern-list-bullets
            '(("*" . "•")
              ("+" . "–")
              ("-" . "—")))
      )
#+end_src
*** Configure Babel Languages
Add a list item to org-babel-load-languages for each language we want to do code blocks for. The conf-unix line lets us do key-value pairs (eg meaning=42) which a lot of *nix programs use for config.
More info [[https://orgmode.org/worg/org-contrib/babel/languages.html][here]].
#+begin_src emacs-lisp
  (let ((babel-languages '((emacs-lisp . t))))
    (when (executable-find "python")
      (push '(python . t) babel-languages))
    (when (executable-find "haskell")
      (push '(haskell . t) babel-languages))
    (org-babel-do-load-languages 'org-babel-load-languages babel-languages))
  (push '("conf-unix" . conf-unix) org-src-lang-modes)

#+end_src
*** Structure Templates
This allows you to type <el TAB or <py TAB and so on to get code blocks inserted into org docs. You can even use it for the custom bits like :tangle or :mkdirp if needed.
More [[https://orgmode.org/manual/Structure-Templates.html][here]].
#+begin_src emacs-lisp
  (use-package org-tempo
     
    :ensure nil ; It's part of org so won't needed installed
    :after org  ; Ensure org is loaded first
    :config
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("hs" . "src haskell")))

#+end_src
** Data Mangt (recutils)
GNU Recutils integration for flat-file databases.
#+begin_src emacs-lisp
  (use-package rec-mode
  :ensure t
  :mode "\\.rec\\'"
  :config
  ;; Visual styling for concerns
  (setq rec-font-lock-keywords
        (append rec-font-lock-keywords
                '(("^Concern: Low" . 'success)
                  ("^Concern: Medium" . 'warning)
                  ("^Concern: High" . 'error)
                  ("^Concern: Critical" . 'error)))))
  
#+end_src
** Dev Stuff
*** Languages
**** Tree-sitter Language Grammars
The command =M-x treesit-install-language-grammar= , which requires *C and git*, will install a language grammar for tree-sitter, but you have to point it at the grammar using the following variable. See [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][Mastering Emacs]] for more.
We can use [[https://github.com/renzmann/treesit-auto][treesit-auto]] to automatically handle installing grammars and mapping modes.
#+begin_src emacs-lisp
  ;; If there's an issue with ts modes opening in language buffers, it might be because of the wrong name
  ;; of mode (java-ts-mode, c-ts-mode) etc being used.
  (use-package treesit-auto
    :ensure t
    :custom
    ;; Ask to install a grammar if it's missing when opening a file
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src
**** Language Server (Eglot)
This section configures the inbuilt (since version 29ish) LSP client. Eglot can find most lang servers (like =clangd=, =jdtls=, etc) in our PATH, but we need to provide explicit config for servers in non-standard locations.
#+begin_src emacs-lisp

  
  (use-package flymake :ensure t)
  (use-package jsonrpc :ensure t)
  (use-package eglot
    :ensure t
    :hook ((haskell-mode . eglot-ensure)
  	 (java-ts-mode . eglot-ensure)
  	 (python-mode . eglot-ensure)
  	 (js-mode . eglot-ensure)
  	 (typescript-mode . eglot-ensure)
  	 (c-ts-mode . eglot-ensure)
  	 (c++-ts-mode . eglot-ensure)
  	 )
    :bind (:map eglot-mode-map
  	      ("M-." . xref-find-definitions)
  	      ("M-," . xref-pop-marker-stack)
  	      ("C-c a" . eglot-code-actions)
  	      )
    :config
    ;(let ((haskell-lsp (or (executable-find "haskell-language-server-wrapper")
    ;                     (expand-file-name "~/.ghcup/bin/haskell-language-server-wrapper"))))
    ;  (when (file-exists-p haskell-lsp)
    ;    (add-to-list 'eglot-server-programs
    ;                 `(haskell-mode . (,haskell-lsp "--lsp")))))
    (setq eglot-auto-server-display nil) ;Don't autodisplay server-buffer on restart
    (setq eglot-events-buffer-size 0)
    (setq eglot-reconnect-on-change t)
    (setq eglot-autodocument t) ; on mouse-over
    (setq eglot-autodocument-delay 1)
    (setq eglot-display-buffer-function #'eglot-display-buffer-at-bottom)
    )
#+end_src
**** C++
C, C++ and cmake settings - using the newer treesitter modes
#+begin_src emacs-lisp
  (defun nij/cmake-configure-preset ()
    "Run 'cmake --preset default' in the project root."
    (interactive)
    (if (executable-find "cmake")
        (let ((compile-command "cmake --preset default")) (compile compile-command))
      (message "Error: 'cmake' not in PATH.")
      ))
#+end_src
#+begin_src emacs-lisp
  (defun nij/c-ts-mode-common-setup ()
    "Common setup for C/C++ tree-sitter modes."
    ;; This replaces 'c-basic-offset' and 'c-set-style'.
    (setq-local treesit-indent-level 4)
      
    ;; Bind keys to the C TS map. 
    ;; c++-ts-mode inherits from c-ts-mode, so it gets these keys too.
    (define-key c-ts-mode-map (kbd "C-c c") #'compile)
    (define-key c-ts-mode-map (kbd "C-c s") #'nij/shell-other-window)
    )
  (defun nij/cpp-ts-mode-setup ()
    "C++ specific setup."
    ;; Bind your C++ specific key
    (nij/c-ts-mode-common-setup)
    (define-key c++-ts-mode-map (kbd "C-c C-p") #'nij/cmake-configure-preset)
    )
  ;; Add the hooks for the new modes
  (add-hook 'c-ts-mode-hook #'nij/c-ts-mode-common-setup)
  (add-hook 'c++-ts-mode-hook #'nij/cpp-ts-mode-setup)
#+end_src
**** Java
Java settings - using the newer treesitter version
#+begin_src emacs-lisp

(defun nij/java-ts-mode-setup ()
  "Keybinds for java-ts-mode."
  (define-key java-ts-mode-map (kbd "C-c c") #'compile))

(add-hook 'java-ts-mode-hook #'nij/java-ts-mode-setup)
#+end_src
**** Javascript/Typescript
Major mode for JS/TS, integrate Prettier, and a REPL.
#+begin_src emacs-lisp
  (use-package typescript-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-mode)
           ("\\.tsx\\'" . typescript-mode))
    :config
    (setq typescript-indent-level 2))

  ;; Only load prettier-js if the 'prettier' executable is found
  (when (executable-find "prettier")
    (use-package prettier-js
      :ensure t
      :hook ((js-mode . prettier-js-mode)
             (typescript-mode . prettier-js-mode)
             (web-mode . prettier-js-mode)
  	   (js-mode . nij/prettier-format-on-save)
             (typescript-mode . nij/prettier-format-on-save))
  	   ))
  (when (executable-find "node")
    (use-package nodejs-repl
      :ensure t
      :bind ((:map js-mode-map
  		 ("C-c C-j" . nodejs-repl-run-current-file))
             (:map typescript-mode-map
  		 ("C-c C-j" . nodejs-repl-run-current-file)))
      ))
#+end_src
**** Haskell
#+begin_src emacs-lisp
  (use-package haskell-mode :ensure nil :defer t)
#+end_src
*** Completion (Corfu)
A lightweight, fast, and modern completion UI
=kind-icon= integrates with =all-the-icons= to provide icons
=cape= provides extra completion at point functions
#+begin_src emacs-lisp
  (use-package kind-icon
    :ensure t
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default)
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
    )

  (use-package corfu
    :ensure t
    ;:after kind-icon ; -- Load after kind-icon
    :init (global-corfu-mode 1)
    :custom
    (corfu-auto t)
    (corfu-auto-prefix 1)
    (corfu-auto-delay 0.0)
    (corfu-cycle t)               ; Allow cycling
    (corfu-popupinfo-delay 0.5)   ; Show extra info in a popup
    ;; We remove this line, as kind-icon handles it now 
    (corfu-format-functions '(corfu-format-default kind-icon-corfu-format))
    :bind
    ;; Binds TAB to 'corfu-complete'.
    (:map corfu-map
          ("<tab>" . corfu-complete)
          ("TAB" . corfu-complete)))
        
  (use-package cape
    :ensure t
    :config
    ;; Add cape's functions to Emacs's built-in completion-at-point-functions
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-dabbrev)
    (add-to-list 'completion-at-point-functions #'cape-keyword)
    ;; We can add others
    )
#+end_src
*** Project Management (Projectile)
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    ;; :defer t is no longer needed, as :bind-keymap and :init handle it
    :diminish projectile-mode
    :custom ((projectile-completion-system 'default))
    :bind-keymap
     ("C-c p" . projectile-command-map)
    :init
    ;; Enable the global minor mode via its autoload
    (projectile-mode 1)
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package consult-projectile
    :ensure t
    :after (projectile consult)
    :bind (:map projectile-command-map
                ("f" . consult-projectile-find-file)
                ("s" . consult-projectile-switch-project)))
#+end_src
*** Version Control (Magit)
Forge, which helps magit use git forges like github, can read ~/.authinfo.gpg for authentication
I put my current github personal access token in there. 
#+begin_src emacs-lisp
  (use-package transient :ensure t) ;; without explicitly installing it, elpaca complains that
                                    ;; the inbuilt version is too old and won't install magit

  (use-package magit
    :ensure t
    :bind (("C-x g" . magit-status)) ;; This implicitly makes it lazy
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  ;; This ensures 'forge' is installed and loaded *after* 'magit',
  ;; so that our local.el file can configure it.
  (use-package forge
    :ensure t
    :after magit)
#+end_src
*** Rainbow Delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src
** File Management (dired)
Some slight customisations. Consider =dired-single= if we get annoyed by the multiple dired buffers. =dired-open= if we want to directly open binary files in eg feh, mpv, etc.
#+begin_src emacs-lisp
  (use-package dired
       
      :ensure nil
      :commands (dired dired-jump)
      :custom ((dired-listing-switches "-alh --group-directories-first")
      	   (wdired-allow-to-change-permissions t))
      :config
      (require 'dired-x))

    ;; Only load all-the-icons-dired if we are in GUI and fonts are installed
  (use-package all-the-icons-dired
    :ensure t
    :hook (dired-mode . all-the-icons-dired-mode)
    :if (nij/all-the-icons-available-p))

  (use-package dired-hide-dotfiles
    :ensure t
    :hook (dired-mode . dired-hide-dotfiles-mode)
    )

  (use-package dired-git-info
  :ensure t
  :hook (dired-mode . (lambda () (ignore-errors (dired-git-info-mode 1)))))
#+end_src
** Remote Access (TRAMP)
Configure remote access, specifically fixing Zsh/Cloudflare latency issues.
- We need TRAMP to use bash rather than zsh to avoid the regex loop hanging connection.
- We can also get TRAMP to avoid checking for git on remote files
#+begin_src emacs-lisp
  (use-package tramp
    :ensure nil
    :config
    (add-to-list 'tramp-connection-properties
                 (list (regexp-quote "/ssh:ssh-nas-tunnel:")
                       "remote-shell" "/bin/bash"))
    
    (add-to-list 'tramp-connection-properties
                 (list (regexp-quote "/ssh:thror:")
                       "remote-shell" "/bin/bash"))
    
    
    (setq vc-ignore-dir-regexp (format "\\(%s\\)\\|\\(%s\\)"
                                       vc-ignore-dir-regexp
                                       tramp-file-name-regexp))
    (setq tramp-verbose 1   ; Reduce logging overhead
        remote-file-name-inhibit-cache nil 
        tramp-ssh-controlmaster-options
        "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=1200") ;; handshake every 20 min not every transaction
    )
#+end_src
** PDF Tools
From [[https://github.com/vedang/pdf-tools][PDF Tools]] - it is awesome, but it needs libpoppler, poppler-glib and epdfinfo on the host system.
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :hook (pdf-view-mode . pdf-view-midnight-minor-mode)
    :defer t
    :commands (pdf-tools-install pdf-loader-install) ; Make install commands available
    :mode ("\\.pdf\\'" . pdf-view-mode)
    :bind (:map pdf-view-mode-map
                ("C-=" . pdf-view-enlarge)
                ("C--" . pdf-view-shrink))
    :config
    ;; Check if the compiled server component is available
    (if (require 'pdf-tools-server nil 'noerror)
        (progn
          (setq revert-without-query (concat "\(" (regexp-quote ".pdf") "\|.*\.pdf\.lock\)")))
      (message "pdf-tools server not compiled. Run 'M-x pdf-tools-install'.")))
#+end_src
** Ebook Reader (nov.el)
This adds support for reading =.epub= files
We'll lazy-load it by associating it with the =.epub= file extension.
#+begin_src emacs-lisp
  (use-package nov
    :ensure t
    :mode ("\\.epub\\'" . nov-mode))
#+end_src
** LaTeX
Lazy-load AUCTeX when a .tex file is opened.
#+begin_src emacs-lisp
  (use-package auctex
    :ensure t
    :mode ("\\.tex\\'" . LaTeX-mode) ; -- This is the lazy-loading trigger
    :config
    ;; Set the default viewing programs
    (setq TeX-view-program-selection
          '(((output-dvi has-no-display-manager) "dvi2tty")
            ((output-dvi style-pstricks) "dvips and gv")
            (output-dvi "xdvi")
            (output-pdf "PDF Tools")) ; auctex will find pdf-tools
          TeX-view-program-list
          '(("PDF Tools" TeX-pdf-tools-sync-view))
          TeX-source-correlate-start-server t)

    ;; Conditionally add 'xdg-open' for HTML if it exists
    (when (executable-find "xdg-open")
      (add-to-list 'TeX-view-program-selection '(output-html "xdg-open")))

    ;; Refresh buffer after compilation
    (add-hook 'TeX-after-compilation-finished-functions
              #'TeX-revert-document-buffer))
#+end_src
** Terminals
*** vterm
A linux-only terminal, based on the libvterm library. We define a helper function to multiplex it and lazy-load the package via keybindings.
#+begin_src emacs-lisp
  (defun nij/vterm-new ()
    "Open a new vterm buffer with a unique name."
    (interactive)
    (vterm (generate-new-buffer-name "*vterm*")))
  (defun nij/vterm-notify (title body)
    "Trigger a desktop notification from vterm."
    (start-process "notify" nil "notify-send" title body))
    
  (use-package vterm
    :ensure t
    :config
    (setq vterm-shell "/bin/bash"
          vterm-max-scrollback 5000)
    (add-to-list 'vterm-eval-cmds '("nij/vterm-notify" nij/vterm-notify))
    :bind (("C-c t" . vterm)
           ("C-c T" . nij/vterm-new))) 
#+end_src
*** eat
Another awesome linux terminal, this one based on the libtsm library. It is more closely integrated into emacs, and uses treesitter.
#+begin_src emacs-lisp
  (defun nij/eat-new ()
    "Open a new eat buffer with a unique name."
    (interactive)
    (eat (generate-new-buffer-name "*eat*")))

  (use-package eat
    :ensure t
    :config
    (setq eat-kill-buffer-on-exit t ; Automatically kill the buffer when the shell exits
          eat-buffer-name-format "*eat %s*" ; Use a distinct naming format
          eat-shell "/bin/bash") ; Use the same shell as vterm
    :bind (("C-c e" . eat)
           ("C-c E" . nij/eat-new))
    :hook (eat-mode . (lambda ()
                        (set-face-attribute 'default nil :inherit 'fixed-pitch))))
#+end_src
*** Remote Shell Workflow
This section configures Eshell to act as a TRAMP-native hub.
The idea is that it should gradually grow to replace the need for external SSH terminals.
#TODO: We NEED to configure detached.el for long-running commands. Can it play with eshell?
#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil
    :config
    ;; 1. Quick Jump Function
    ;; Usage: Type 'j thror', 'j girion', or 'j root' in Eshell
    (defun eshell/j (target)
      "Quickly jump to a TRAMP target or bookmark."
      (let ((path (cond
                   ;; Thror (Ubuntu NAS) - Standard User
                   ((member target '("thror" "t")) "/ssh:thror:/home/nij")
                   
                   ;; Thror - Root Access (TRAMP Multi-hop)
                   ;; This hops via ssh:thror, then sudo:root on thror
                   ((member target '("root-thror" "rt")) "/ssh:thror|sudo:thror:/root")

                   ;; Girion (TrueNAS) - Admin/Docker Management
                   ;; Note: Using ssh-nas-tunnel based on your SSH config
                   ((member target '("girion" "g" "nas")) "/ssh:truenas_admin@ssh-nas-tunnel:/mnt/main-pool")
                   
                   ;; Fallback: acts like normal cd
                   (t target))))
        (eshell/cd path)
        (eshell/echo (format "Warped to %s" path))))

    ;; 2. Smart Prompt (Shortens remote paths)
    ;; Instead of /ssh:user@host:/path/to/dir $ 
    ;; It will show: [host] /path/to/dir $
    (setq eshell-prompt-function
          (lambda ()
            (concat
              (if (file-remote-p default-directory)
                 (let ((vec (tramp-dissect-file-name default-directory)))
                   (format "[%s] " (tramp-file-name-host vec)))
               "")
             (abbreviate-file-name (eshell/pwd))
             (if (= (user-uid) 0) " # " " $ "))))
    )
#+end_src

*** Eat Visual Integration
Since we are using the 'eat' terminal, we can tell Eshell to use 'eat' to render visual programs automatically.
#+begin_src emacs-lisp
  (use-package eat
    :ensure t
    :hook (eshell-load . eat-eshell-mode)
    :config
    ;; When you type 'htop' or 'vim' in Eshell, it will temporarily 
    ;; turn into a full terminal emulator.
    (add-to-list 'eat-eshell-visual-commands "htop")
    (add-to-list 'eat-eshell-visual-commands "btop")
    (add-to-list 'eat-eshell-visual-commands "nvtop")
    (add-to-list 'eat-eshell-visual-commands "vim") 
    (add-to-list 'eat-eshell-visual-commands "nano"))
#+end_src
** **Portability** (Load Local Config)
This block loads a machine-specific configuration file, =local.el=, if it exists.
This file is not part of the main config and should be added to .gitignore.
It's used to set machine-specific variables, like file paths.
#+begin_src emacs-lisp
(let ((local-config (expand-file-name "local.el" user-emacs-directory)))
  (when (file-exists-p local-config)
    (load-file local-config)))
#+end_src
* Vague thoughts and navel-gazing
- The intent here has been a readable, maintainable, modern, portable config.
- I should try and make a =portable emacs= that will run on a usb stick on a restrictive windows box, eg a client's machine
- I should consider other extensions to =vertico, corfu, and org= - =org-roam= is an important one to look into
- At some point, I should try and get music, video (=EMMS=?), IRC (=ERC=?), =RSS=, email (=mu4e=?), and =matrix= working.
- I should figure out why the =eat terminal jerks= through output sometimes rather than scrolling smoothly
- There is also the telegram integration (=telega=?) and the recent whatsapp integration project
- I'd also like to experiment with =EXWM=
- there's a new =reader-mode= that does pdf and epub

* Future Experiments (more fleshed out thoughts)
** Emacs Application Framework (EAF)
This is not in MELPA due to heavy external dependencies (Qt6/Python). So I'm avoiding it for now.
Dependencies (Arch): ~sudo pacman -S python-pip qt6-base qt6-webengine qt6-svg qt6-declarative~
~mkdir ~/.emacs.d/site-lisp/eaf~
~git clone --depth=1 -b master https://github.com/emacs-eaf/emacs-application-framework.git ~/.emacs.d/site-lisp/eaf~
#+begin_src emacs-lisp
;  (use-package eaf
;    :load-path "~/.emacs.d/site-lisp/eaf" ; Requires manual clone!
;    :custom
;    (eaf-browser-continue-where-left-off t)
;    (eaf-browser-enable-adblocker t)
;    (browse-url-browser-function 'eaf-open-browser)
;    :config
;    (defalias 'browse-web #'eaf-open-browser)
;    (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
;    (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
;  ;;   (require 'eaf-markmap)
;    )
;  (require 'eaf-browser)
;  (require 'eaf-pdf-viewer)
;  (require 'eaf-system-monitor)
;  (require 'eaf-demo)
;  (require 'eaf-pyqterminal)
;  (require 'eaf-pdf-viewer)
;  (require 'eaf-browser)
;  (require 'eaf-vue-tailwindcss)
;  (require 'eaf-camera)
;  (require 'eaf-vue-demo)

#+end_src
* Footer
;; This sets a buffer-local hook to tangle the file on save.
;; Because it is in 'Local Variables', it applies only to this file.
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:  
